# DNS：域名系统

> 域名系统（`DNS`）是一种用于`TCP/IP`应用程序的分布式数据库，它提供主机名字和`IP`地址之间的转换及有关电子邮件的选路信息。这里提到的分布式是指在`Internet`上的单个站点不能拥有所有的信息。

从应用的角度来看，对`DNS`的访问是 通过一个地址解析器（`resolver`）来完成的，在`Unix`主机中，该解析器通过两个库函数`gethostbyname(3)`和`gethostbyaddress(3)`来完成访问，解析器通过一个或多个名字服务器来完成这种相互转换。 

`DNS`的名字空间和`Unix`的文件系统相似，也具有层次结构。每个结点有一个至多`63`个字符长的标识，这颗树的树根是没有任何标识的特殊结点。以点"."结尾的域名称为绝对域名或完全合格的域名`FQDN（Full Qualified Domain Name）`，例如`sun.tuc.noao.edu`。

![dns-header-data](./reference-media/dns-header-data.png)	

`DNS`定义一个用于查询和响应的报文格式，这个报文由`12`字节长的首部和`4`个长度可变的字段组成。

从最左边开始依次介绍各字段：

`QR`是`1 bit`字段：`0`表示查询报文，`1`表示响应报文；

`opcode`是一个`4 bit	`字段，通常值为`0`（标准查询），其它值为`1	`（反向查询）和`2	`（服务器状态请求）；

`AA`是`1 bit`标志，表示授权回答`(authoritative answer)`，该名字服务器是授权于该域的；

`TC`是`1 bit`标志，表示可截断`（truncated）`，使用`UDP`时，它表示当应答的总长度超过`512`字节时，只返回前`512	`字节；

`RD`是`1 bit`字段表示“期望递归`（recursion desired）`”，该比特能在一个查询中设置，并在响应中返回；

**高速缓存**，为了减少`Internet`上`DNS`的通信量，所有的名字服务器均使用高速缓存。在标准的`Unix`实现中，高速缓存是由名字服务器而不是由名字解析器维护的。在默认情况下，名字解析器在本地主机，`UDP`端口号为`53`或`TCP`端口号为`53`，寻找名字服务器。

```
madong@spotify-mac tcpip-illustrated-network % cat /etc/resolv.conf 
#
# macOS Notice
#
# This file is not consulted for DNS hostname resolution, address
# resolution, or the DNS query routing mechanism used by most
# processes on this system.
#
# To view the DNS configuration used by this system, use:
#   scutil --dns
#
# SEE ALSO
#   dns-sd(1), scutil(8)
#
# This file is automatically generated.
#
nameserver 240e:40:8000::10
nameserver 240e:40:8000::11
```

当名字服务器发出一个虚拟请求，并且返回响应中的`TC`（删减标志）比特被设置为`1`时，它就意味着响应的长度超过了`512`个字节，而仅仅返回前`512`个字节。



## TFTP：简单文件传送协议

`TFTP（Trivial File Transfer Protocol）`即简单文件传送协议，最初打算用于引导无盘系统（通常是工作站或`X`终端）。为了保持简单和短小，`TFTP`将使用`UDP`，`TFTP`的实现（和它所需要的`UDP`、`IP`和设备驱动程序）可以被放入只读存储器中。

之前有介绍一个无盘系统，它在不知道自身`IP`地址的情况下，在进行系统引导时能够通过`RARP`来获取它的`ip`地址。然而使用`RARP`有两个问题：1）`IP`地址是返回的唯一地址；2）既然`RARP`使用链路层广播，`RARP`请求就不会被路由器转发（迫使每个物理网络设置一个`RARP`服务器），使用无盘系统进行引导的程序协议，及`BOOTP`。



## TCP：传输控制协议

尽管`TCP`和`UDP`都使用相同的网络层（`IP`），`TCP`却向应用层提供与`UDP`完全不同的服务。`TCP`提供一种面向连接的、可靠的字节流服务。面向连接意味着两个使用`TCP`的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个`TCP`连接。

![tcp-header-data](./reference-media/tcp-header-data.png)	

每个`TCP`段都包含源端和目的端的端口号，用于寻找发端和收端应用进程。这两个值加上`IP`首部中的源端`IP`地址和目的端`IP`地址唯一确定一个`TCP`连接。

序号用来标识从`TCP`发端向`TCP`收到发送的数据字节流，它表示在这个报文段中的第一个数据字节。如果将字节流看作两个应用程序间的单向流动，则`TCP`用序号对每个字节进行统计计数，序号是`32 bit`的无符号数。

当建立一个新的连接时，`SYN`标志变`1`。序号字段包含由这个主机选择的该连接的初始序。因此，确认序号应当是上次已成功收到数据字节序号加`1`。只有`ACK`标志为`1`时确认序号字段才有效。

`TCP`为应用层提供全双工服务，这意味数据能在两个方向上独立地进行传输。因此，连接的每一端必须保持每个方向上的传输数据序号。我们说`TCP`缺少选择确认是因为`TCP`首部中的确认序号表示发方已成功收到字节，但还不包含确认序号所指的字节。

`TCP`的流量控制由连接的每一端通过声明的窗口大小来提供，窗口大小为字节数。起始于确认序号字段指明的值，这个值是接收端正期望接收的字节。窗口大小是一个`16 bit`字段，因而窗口大小最大为`65535`字节。

校验和覆盖了整个的`TCP`报文段：`TCP`首部和`TCP`数据，这是一个强制性的字段，一定是由发端计算和存储，并由收端进行验证。



## TCP连接的建立与终止

`TCP`是一个面向连接的协议，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。

```shell
10:56:20.936702 IP sam-virtual-machine.49532 > 192.168.100.86.ssh: Flags [P.], seq 296:340, ack 977, win 65526, length 44
10:56:20.937179 IP 192.168.100.86.ssh > sam-virtual-machine.49532: Flags [.], ack 340, win 64240, length 0
10:56:20.948491 IP 192.168.100.86.ssh > sam-virtual-machine.49532: Flags [P.], seq 977:1037, ack 340, win 64240, length 60
10:56:20.948534 IP sam-virtual-machine.49532 > 192.168.100.86.ssh: Flags [.], ack 1037, win 65526, length 0
10:56:21.423095 IP 192.168.170.1.64519 > 239.255.255.250.1900: UDP, length 174
10:56:21.621338 IP sam-virtual-machine.49532 > 192.168.100.86.ssh: Flags [P.], seq 340:376, ack 1037, win 65526, length 36
10:56:21.621933 IP 192.168.100.86.ssh > sam-virtual-machine.49532: Flags [.], ack 376, win 64240, length 0
10:56:21.635420 IP 192.168.100.86.ssh > sam-virtual-machine.49532: Flags [P.], seq 1037:1073, ack 376, win 64240, length 36
10:56:21.635459 IP sam-virtual-machine.49532 > 192.168.100.86.ssh: Flags [.], ack 1073, win 65526, length 0
10:56:21.637752 IP 192.168.100.86.ssh > sam-virtual-machine.49532: Flags [P.], seq 1073:1241, ack 376, win 64240, length 168
10:56:21.637789 IP sam-virtual-machine.49532 > 192.168.100.86.ssh: Flags [.], ack 1241, win 65526, length 0
10:56:22.425062 IP 192.168.170.1.64519 > 239.255.255.250.1900: UDP, length 174
10:56:23.426444 IP 192.168.170.1.64519 > 239.255.255.250.1900: UDP, length 174
10:56:24.428201 IP 192.168.170.1.64519 > 239.255.255.250.1900: UDP, length 174
10:56:30.959390 IP sam-virtual-machine.49532 > 192.168.100.86.ssh: Flags [P.], seq 376:412, ack 1241, win 65526, length 36
10:56:30.959986 IP 192.168.100.86.ssh > sam-virtual-machine.49532: Flags [.], ack 412, win 64240, length 0
10:56:30.970358 IP 192.168.100.86.ssh > sam-virtual-machine.49532: Flags [P.], seq 1241:1277, ack 412, win 64240, length 36
10:56:30.970421 IP sam-virtual-machine.49532 > 192.168.100.86.ssh: Flags [.], ack 1277, win 65526, length 0
10:56:30.973172 IP 192.168.100.86.ssh > sam-virtual-machine.49532: Flags [P.], seq 1277:1353, ack 412, win 64240, length 76
10:56:30.973196 IP sam-virtual-machine.49532 > 192.168.100.86.ssh: Flags [.], ack 1353, win 65526, length 0
10:56:30.997844 IP 192.168.100.86.ssh > sam-virtual-machine.49532: Flags [P.], seq 1353:1469, ack 412, win 64240, length 116
10:56:30.997913 IP sam-virtual-machine.49532 > 192.168.100.86.ssh: Flags [.], ack 1469, win 65526, length 0
```

对于`TCP`段，每个输入行开始按如下格式显示：源 > 目的:标志；

标志代表`TCP`首部中`6`个标志比特中的`4`个，`S`-`SYN`，译为同步序号；`F`-`FIN`，译为发送方完成数据发送；`R`-`RST`，复位连接；`P`-`PUSH`，尽可能快地将数据发往接收进程。

第`1`行中，字段`1415531521:1415531521(0)`表示分组的序号是``1415531521`，而报文段中数据字节数为`0`。`tcpdump`显示这个字段个格式是开始的序号，一个冒号，隐含的结尾序号及圆括号内的数据字节数。

在第`2`行中，字段`ack 1415531521`表示确认序号，它只有在首部中的`ack`标志比特被设置`1	`时才显示。

每行显示的字段`win 4096`表示发端通告的窗口大小，在这些例子中，我们没有交换任何数据，窗口大小就维持默认情况下的`4096`。最后一个字段`<mss 1024>`表示由发端指明的最大报文长度选项，发端将不接收超过这个长度的`TCP`报文层，这通常是为了避免分段。

**`TCP/IP`三次握手的过程**（面试及考试都会遇到）：

1）请求端（通常称为客户）发送一个`SYN`段指明客户打算连接的服务器端口，以及初始序号（`ISN`，在例子中为`1415531521`），这个`SYN`段为报文段`1`；

2）服务器发回包含服务器的初始化的`SYN`报文段（报文段`2`）作为应答。同时，将确认序号设置为客户的`ISN`加`1`以对客户`SYN`报文段进行确认，一个`SYN`将占用一个序号；

3）客户必须将确认序号设置位服务器的`ISN`加`1`以对服务器的`SYN`报文段进行确认（报文段`3`）；

这三个报文段完成连接的建立，这个过程也称为三次握手（`three way handshake`）。发送第一个`SYN`的一端将执行主动打开（`a ctive open`），接收这个`SYN`并发回下一个`SYN`的另一端执行被动打开（`passive open`）。

